// ⢸⣿⣿⣿⣿⠃⠄⢀⣴⡾⠃⠄⠄⠄⠄⠄⠈⠺⠟⠛⠛⠛⠛⠻⢿⣿⣿⣿⣿⣶⣤⡀⠄
// ⢸⣿⣿⣿⡟⢀⣴⣿⡿⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣸⣿⣿⣿⣿⣿⣿⣿⣷
// ⢸⣿⣿⠟⣴⣿⡿⡟⡼⢹⣷⢲⡶⣖⣾⣶⢄⠄⠄⠄⠄⠄⢀⣼⣿⢿⣿⣿⣿⣿⣿⣿⣿
// ⢸⣿⢫⣾⣿⡟⣾⡸⢠⡿⢳⡿⠍⣼⣿⢏⣿⣷⢄⡀⠄⢠⣾⢻⣿⣸⣿⣿⣿⣿⣿⣿⣿
// ⡿⣡⣿⣿⡟⡼⡁⠁⣰⠂⡾⠉⢨⣿⠃⣿⡿⠍⣾⣟⢤⣿⢇⣿⢇⣿⣿⢿⣿⣿⣿⣿⣿
// ⣱⣿⣿⡟⡐⣰⣧⡷⣿⣴⣧⣤⣼⣯⢸⡿⠁⣰⠟⢀⣼⠏⣲⠏⢸⣿⡟⣿⣿⣿⣿⣿⣿
// ⣿⣿⡟⠁⠄⠟⣁⠄⢡⣿⣿⣿⣿⣿⣿⣦⣼⢟⢀⡼⠃⡹⠃⡀⢸⡿⢸⣿⣿⣿⣿⣿⡟
// ⣿⣿⠃⠄⢀⣾⠋⠓⢰⣿⣿⣿⣿⣿⣿⠿⣿⣿⣾⣅⢔⣕⡇⡇⡼⢁⣿⣿⣿⣿⣿⣿⢣
// ⣿⡟⠄⠄⣾⣇⠷⣢⣿⣿⣿⣿⣿⣿⣿⣭⣀⡈⠙⢿⣿⣿⡇⡧⢁⣾⣿⣿⣿⣿⣿⢏⣾
// ⣿⡇⠄⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢻⠇⠄⠄⢿⣿⡇⢡⣾⣿⣿⣿⣿⣿⣏⣼⣿
// ⣿⣷⢰⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢰⣧⣀⡄⢀⠘⡿⣰⣿⣿⣿⣿⣿⣿⠟⣼⣿⣿
// ⢹⣿⢸⣿⣿⠟⠻⢿⣿⣿⣿⣿⣿⣿⣿⣶⣭⣉⣤⣿⢈⣼⣿⣿⣿⣿⣿⣿⠏⣾⣹⣿⣿
// ⢸⠇⡜⣿⡟⠄⠄⠄⠈⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣻⣿⣿⣿⣿⣿⠟⠁⢳⠃⣿⣿⣿
// ⠄⣰⡗⠹⣿⣄⠄⠄⠄⢀⣿⣿⣿⣿⣿⣿⠟⣅⣥⣿⣿⣿⣿⠿⠋⠄⠄⣾⡌⢠⣿⡿⠃
// ⠜⠋⢠⣷⢻⣿⣿⣶⣾⣿⣿⣿⣿⠿⣛⣥⣾⣿⠿⠟⠛⠉⠄⠄


#include "bits/stdc++.h"
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace __gnu_pbds;
using namespace std;

#define endl "\n"
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3f
#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef tree<int,null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<int,null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> multiordered_set;  //--set.lower_bound(value) ao inves de find

mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());

const int mod = 1e9+7;

signed solve(){
    
    ll k; cin >> k;

    string s,t; cin >> s >> t;

    ll l1 = 1, r1 = 2e17;

    ll ans = 0;

    int n = s.size(), m = t.size();

    vector<vector<int>> sum(n, vector<int>(26, 0));

    for(int i = 0; i < n; i++){
        if(i > 0){
            for(int j = 0; j < 26; j++) sum[i][j] = sum[i-1][j];
        }

        sum[i][s[i]-'a']++;
    }

    while(l1 <= r1){

        ll md1 = (l1+r1)/2;

        ll ag = 0;

        int p = -1;

        for(char cf: t){
            int c = cf-'a';

            if(sum[n-1][c] == 0){
                cout << 0 << endl;
                return 0;
            }

            if(p == -1){
                ag += md1 / sum[n-1][c];

                int h = md1 % sum[n-1][c];

                if(h == 0){
                    ag--; h = sum[n-1][c];
                }

                for(int i = 0; i < n; i++){
                    if(sum[i][c] == h){
                        p = i;
                        break;
                    }
                }

                continue;
            }

            ag += md1/sum[n-1][c];

            int h = md1 % sum[n-1][c];

            if(h == 0){
                ag--; h = sum[n-1][c];
            }

            int l = 1, r = n;

            int csz = -1;

            while(l <= r){          //pensar no caso em que ele pega todos mas n precisa terminar a volta completa
                int sz = (l+r)/2;

                int cc = 0;

                if(p + sz >= n){
                    cc += sum[n-1][c] - sum[p][c];
                    int szl = sz - (n-1 - p);
                    cc += sum[szl-1][c];
                }

                else{
                    cc += sum[p+sz][c] - sum[p][c];
                }

                if(cc >= h){
                    r = sz-1;
                    csz = sz;
                }
                else l = sz+1;
            }

            if(p + csz >= n){
                ag++;
                p = csz - (n-1 - p); p--;
            }

            else{
                p = p + csz;
            }

            if(ag >= k) break;
        }

        if(ag >= k){
            r1 = md1-1;
        }
        else{
            l1 = md1+1;
            ans = md1;
        }
    }

    cout << ans << endl;


    return 0;
}

signed main(){
    fastio;

    int t = 1;
    // cin >> t;
    while(t--){
        solve();
    }    

    return 0;
}